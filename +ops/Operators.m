%% Class for boundary operators
%
% <latex>
% \section{Introduction}
% Let $D_1, D_2$ be two $C^2$ shapes (C2boundary objects) which are either
% disjoint, or identical. Define $A: L^2(\partial D_1) \rightarrow
% L^2(\partial D_2)$ a linear operator which has the form: 
% $$Af(y) = \int_0^{2\pi} k(y, x(t)) f(x(t)) |x'(t)| dt, \ y\in\partial
% D_2,$$
% where $k(y,x)$ is the integration kernel. We define the \emph{kernel matrix}:
% $$(K)_{ji}:=k(y(t_j), x(t_i))\sigma_1(t_i),$$
% with $\sigma_1$ the vector of integration elements of $\partial D_1$, and
% in case that $A$ is identity, we define $K_{ji}=\delta_{ji}$. Then
% $Af(y(t_j))$ can be approximated by:
% $$\sum_i k(y(t_j), x(t_i)) f(x(t_i)) \sigma_1(t_i) = \sum_i K_{ji}f(x(t_i)).$$
% \subsection{Stiffness matrix}
% Consider the linear system:
% $$Af = b, \ f\in L^2(\partial D_1), \mbox{ and } b\in L^2(\partial D_2)$$
% We solve it in an internal approximation space of $L^2(\partial D_1)$
% generated by a boundary element basis $\{\psi_n, n=1..N\}$. The
% corresponding variational formulation reads:
% $$\sum_n \langle A\psi_n, \phi_m \rangle f_n = \langle b, \phi_m\rangle, \mbox{ for } m=1..M$$
% with $\{\phi_m, m=1..M\}$ a boundary element basis of $\partial D_2$. 
% We introduce the \emph{stiffness matrix} $(A)_{mn}:=\langle A\psi_n, \phi_m
% \rangle$, where $\psi_n, \phi_m$ are basis functions. In the current version, the class
% \texttt{Operators} can handle the P0 and the P1 basis. The P0 basis is
% defined in a discrete manner as $\psi_m(y(t_j))=\delta_{mj}$ (similarly for $\phi_n$), and the P1
% basis is the classical hat function. The scalar product as well as the stiffness matrix $A$ are
% computed differently depending on the combination of $\psi_n, \phi_m$. 
%
% If $\phi_m$ is the P0 basis, then the scalar product $\langle A\psi_n, \phi_m \rangle$ is
% understood as the point value of $A\psi_n$ at the boundary point $x(t_m)\in\partial D_2$, so the
% stiffness matrix is approximated by: $$(A)_{mn} \simeq \sum_j\phi_m(y(t_j))\sum_i K_{ji}
% \psi_n(x(t_i)).$$ If $\phi_m$ is the P1 basis, the scalar product is understood as a boundary
% integral on $\partial D_2$, and the stiffness matrix is approximated by: $$(A)_{mn} \simeq
% \sum_j\phi_m(y(t_j))\sigma_2(t_j)\sum_i K_{ji} \psi_n(x(t_i)).$$
% \\
% Let Px-Py mean taking the Px basis for $\psi_n$ and Py basis for
% $\phi_m$, then one has the following expressions for $(A)_{mn}$: 
% \begin{itemize} 
% \item P0-P0: $K_{mn}$ 
% \item P0-P1: $\sum_j \phi_m(y(t_j)) \sigma_2(t_j) K_{jn} =(\Phi^\top\Sigma_2 K)_{mn}$
% \item P1-P0: $\sum_i K_{mi}\psi_n(x(t_i)) = (K\Psi)_{mn}$ 
% \item P1-P1: $\sum_j\phi_m(y(t_j))\sigma_2(t_j)\sum_i K_{ji} \psi_n(x(t_i)) = (\Phi^\top\Sigma_2 K\Psi)_{mn}$
% \end{itemize} 
% Here $\Sigma_2=\mbox{diag}(\sigma_2(t_1)\ldots)$, $\Phi=[\phi_1, \ldots
% \phi_M]$, and $\Psi=[\psi_1,\ldots \psi_N]$. </latex>
%

%%
classdef Operators < handle
% Abstract class for linear (integral) operators defined on two
% boundaries. This class provides interfaces for the stiffness matrix
% and the application of the operator.
    
    properties(SetAccess = protected)
        D1 % boundary of the domain of the operator
        typeBEM1 % type of boundary elements for D1
        nbBEM1 % number of boundary elements for D1 (GET)
        stepBEM1 % step length for D1 boundary elements
        Psi % Basis for D1
        Psi_t % adjoint of Psi
        
        D2 % boundary of the image of the operator
        typeBEM2 % type of boundary elements for D2
        nbBEM2 % number of boundary elements for D2 (GET)
        stepBEM2 % step length for D2 boundary elements
        Phi % Basis for D2
        Phi_t % adjoint of Phi
        
        Kmat % kernel matrix
        stiffmat% stiffness matrix representation of the operator
    end
    
    methods(Abstract, Static)
        K = make_kernel_matrix() % Compute the kernel matrix of the operator
        val = eval() % evaluate the operator
    end
    
    methods
        function obj = Operators(D1, type1, step1, D2, type2, step2)
            obj.D1 = D1;
            obj.typeBEM1 = type1;
            obj.D2 = D2;
            obj.typeBEM2 = type2;
            
            switch obj.typeBEM1
              case 'P0' 
                % If P0 basis then the dimension of the approximation space equals to the number of
                % boundary points

                % obj.Psi = [];
                obj.Psi = diag(D1.nbPoints);
                obj.stepBEM1 = 1;
              case 'P1'
                if mod(D1.nbPoints, step1)
                    error('Invalid sampling step for D1');
                end
                obj.stepBEM1 = step1;
                obj.Psi = tools.BEM.P1_basis(D1.nbPoints, step1);
              otherwise
                error('Type Error: only P0 and P1 elements are supported in the current version.');
            end
            
            switch obj.typeBEM2
              case 'P0'
                % obj.Phi = [];
                obj.Phi = diag(D2.nbPoints);                
                obj.stepBEM2 = 1;
              case 'P1'
                if mod(D2.nbPoints, step2)
                    error('Invalid sampling step for D2');
                end
                obj.stepBEM2 = step2;
                obj.Phi = tools.BEM.P1_basis(D2.nbPoints, step2);
              otherwise
                error('Type Error: only P0 and P1 elements are supported in the current version.');
            end
            
            obj.Psi_t = obj.Psi';
            obj.Phi_t = obj.Phi';
        end
        
        function val = get.nbBEM1(obj)
            val = floor(obj.D1.nbPoints / obj.stepBEM1);
        end
        
        function val = get.nbBEM2(obj)
            val = floor(obj.D2.nbPoints / obj.stepBEM2);
        end
        
        function val = fwd(obj, f)
        % Apply the operator $A$ on a $L^2(\partial D_1)$ function $f$
        % represented by its synthesis coefficients wrt the BEM basis
        % $\Psi$. The result is the samples of $Af$ on $\partial D_2$.
        % This is different with the application of stiffness matrix
        % which yields the analysis coefficient of $Af$ wrt the
        % basis on $\partial D_2$.
            val = obj.Kmat * obj.Psi * f;

            % if strcmp(obj.typeBEM1, 'P0')
            %     val = obj.Kmat * f ;
            % elseif  ~strcmp(obj.typeBEM1, 'P0')
            %     val = obj.Kmat * obj.Psi * f;
            % end
        end
        
        function val = get.stiffmat(obj)
            val = obj.get_stiffmat();
        end
        
        function val = get_stiffmat(obj)
        % Export the stiffness matrix
            sigma2 = diag(obj.D2.sigma);
            
            if strcmp(obj.typeBEM1, 'P0') && strcmp(obj.typeBEM2, 'P0')
                val = obj.Kmat;
            elseif strcmp(obj.typeBEM1, 'P0') && ~strcmp(obj.typeBEM2, 'P0')
                val = obj.Phi_t * sigma2 * obj.Kmat;
            elseif ~strcmp(obj.typeBEM1, 'P0') && strcmp(obj.typeBEM2, 'P0')
                val = obj.Kmat * obj.Psi;
            elseif ~strcmp(obj.typeBEM1, 'P0') && ~strcmp(obj.typeBEM2, 'P0')
                val = obj.Phi_t * sigma2 * obj.Kmat * obj.Psi;
            else
                error('Not implemented');
            end
            
        end
        
        % function val = apply_stiffmat(obj, f)
        % % Apply the stiffness matrix on a vector without explicitly
        % % construct the matrix
        %     sigma2 = obj.D2.sigma(:);
            
        %     if strcmp(obj.typeBEM1, 'P0') && strcmp(obj.typeBEM2, 'P0')
        %         val = sigma2 .* (obj.Kmat * f) ;
        %     elseif strcmp(obj.typeBEM1, 'P0') && ~strcmp(obj.typeBEM2, 'P0')
        %         val = obj.Phi_t * (sigma2 .* (obj.Kmat * f));
        %     elseif ~strcmp(obj.typeBEM1, 'P0') && strcmp(obj.typeBEM2, 'P0')
        %         val = sigma2 .* (obj.Kmat * (obj.Psi * f));
        %     elseif ~strcmp(obj.typeBEM1, 'P0') && ~strcmp(obj.typeBEM2, 'P0')
        %         val = obj.Phi_t * (sigma2 .* (obj.Kmat * (obj.Psi * f)));
        %     else
        %         error('Not implemented');
        %     end
        % end
        
    end    
end


% % Old version of documentation
% Let Px-Py means taking the Px basis for $\psi_n$ and Py basis for
% $\phi_m$, then one has the following approximation for $\langle A\psi_n,
% \phi_m \rangle$: 
% \begin{itemize} 
% \item P0-P0: $\sigma_2(t_m) K_{mn} = (\Sigma_2 K)_{mn}$ 
% \item P0-P1: $\sum_j \phi_m(y(t_j)) \sigma_2(t_j) K_{jn} =(\Phi^\top\Sigma_2 K)_{mn}$
% \item P1-P0: $\sigma_2(t_m) \sum_i K_{mi}\psi_n(x(t_i)) = (\Sigma_2 K\Psi)_{mn}$ 
% \item P1-P1: $\sum_j\phi_m(y(t_j))\sigma_2(t_j)\sum_i K_{ji} \psi_n(x(t_i)) = (\Phi^\top\Sigma_2 K\Psi)_{mn}$ 
% \end{itemize} 
% Here $\Sigma_2=\mbox{diag}(\sigma_2(t_1)\ldots)$, $\Phi=[\phi_1, \ldots
% \phi_M]$, and $\Psi=[\psi_1,\ldots \psi_N]$. </latex>
